part of squid;

var defaultResponseRenderer = <ContentType, Renderer>{ContentType.json: jsonRenderer, ContentType.text: stringRenderer};

/// [Response] is the representation of an out coming HTTP request.
///
/// [Response] will provide simple function to interact with the response
/// of the HTTP request and provide helpers function but style exposing the underlying [HttpResponse]
class Response {
  Response(this._response);

  /// Underlying [HttpResponse]
  HttpResponse _response;

  Map<ContentType, Renderer> renderers = Map.from(defaultResponseRenderer);

  /// get response content
  dynamic get body => this._response;

  HttpHeaders get headers => this._response.headers;

  HttpResponse get raw => this._response;

  void redirect(String content, [int code = HttpStatus.movedTemporarily]) {
    this.status = code;
    this._response.write(content);
  }

  int get status => this._response.statusCode;

  void set status(int statusCode) => this._response.statusCode = statusCode;

  ContentType get type => this.headers?.contentType;

  void set type(ContentType type) => this.headers.contentType = type;

  void json(dynamic body) {
    this.render(ContentType.json, body);
  }
  
  void text(dynamic body) {
    this.render(ContentType.text, body);
  }

  void render(ContentType type, dynamic body, [ContentType exportType]) {
    this.type = exportType ?? type;
    this._response.write(this.renderers[type](body));
  }

  /// Adds byte [data] to the target consumer, ignoring [encoding].
  ///
  /// The [encoding] does not apply to this method, and the `data` list is passed
  /// directly to the target consumer as a stream event.
  ///
  /// This function must not be called when a stream is currently being added
  /// using [addStream].
  ///
  /// This operation is non-blocking. See [flush] or [done] for how to get any
  /// errors generated by this call.
  ///
  /// The data list should not be modified after it has been passed to `add`.
  void add(List<int> data) => this._response.add(data);

  /// Iterates over the given [objects] and [write]s them in sequence.
  ///
  /// If [separator] is provided, a `write` with the `separator` is performed
  /// between any two elements of objects`.
  ///
  /// This operation is non-blocking. See [flush] or [done] for how to get any
  /// errors generated by this call.
  void writeAll(Iterable objects, [String separator = ""]) {
    this._response.writeAll(objects, separator);
  }

  /// Passes the error to the target consumer as an error event.
  ///
  /// This function must not be called when a stream is currently being added
  /// using [addStream].
  ///
  /// This operation is non-blocking. See [flush] or [done] for how to get any
  /// errors generated by this call.
  void addError(Error error, [StackTrace stackTrace]) {
    this._response.addError(error, stackTrace);
  }

  /// Adds all elements of the given [stream] to `this`.
  ///
  /// Returns a [Future] that completes when
  /// all elements of the given [stream] are added to `this`.
  Future addStream(Stream<List<int>> stream) {
    return this._response.addStream(stream);
  }

  /// Returns a [Future] that completes once all buffered data is accepted by the
  /// underlying [StreamConsumer].
  ///
  /// This method must not be called while an [addStream] is incomplete.
  ///
  /// NOTE: This is not necessarily the same as the data being flushed by the
  /// operating system.
  Future flush() {
    return this._response.flush();
  }

  /// Close the target consumer.
  ///
  /// NOTE: Writes to the [IOSink] may be buffered, and may not be flushed by
  /// a call to `close()`. To flush all buffered writes, call `flush()` before
  /// calling `close()`.
  Future close() {
    return this._response.close();
  }

  /// Get a future that will complete when the consumer closes, or when an
  /// error occurs. This future is identical to the future returned by
  /// [close].
  Future get done => this._response.done;
}
